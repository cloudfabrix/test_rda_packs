%% stream = no and limit = 0

%% import_src_type = "agent"

@exec:get-input
    ## --> @dm:recall name="temp_input"
    --> @dm:save name="temp-input"

--> @c:new-block
    --> @dm:empty
    --> @dm:recall name="temp-input"
    --> @dm:eval source  ="'Counts'"
    --> @dm:eval discovery_status ="'In Progress'"
    --> @dm:copy-columns from="current_time" and to="discovery_time"
    --> @dm:eval unique_id = "str(current_time)+'_'+ingestion_id+'_'+source"
    --> @dm:to-type columns="discovery_time" and type="int"
    --> @dm:selectcolumns include="customerTag|customerId|projectId|source|unique_id|ingestion_id|discovery_time|discovery_status"
    --> @rn:write-stream name= "discovery_run_details"

--> @c:data-loop columns="ingestion_id" and dataset="temp-input"
    --> @dm:empty
    --> @dm:addrow status = "Triggered pipeline to discover and process the data for each device."
    --> @dm:eval source ="'Logs'"
    --> @dm:eval ingestion_id="'$ingestion_id'"
    --> @dm:eval unique_id = "ingestion_id+'_'+status"
    --> @rn:write-stream name= "discovery_run_details"

--> @c:new-block
    --> @dm:recall name="temp-input"
    --> @dm:check-columns must_contain="IP" and action="skip-block"
    --> @dm:check-columns must_contain="IP" and action="skip-block"
    --> @dm:eval name="'network_access_verification'"  & limit = '0'
    --> #dm:query-persistent-stream ip_address=="{{row.IP}}"
    --> @dm:fail-if-shape row_count=0
    --> *dm:filter protocol contains "snmp"
    --> *dm:filter auth_state == "Success"
    --> *dm:filter timestamp is after -72h
    --> @dm:dedup columns = "ip_address"
    --> @dm:save name="temp-ips"
    --> @dm:fail-if-shape row_count=0
    --> @dm:selectcolumns include ="ip_address"
    --> @dm:eval key ="'key'"
    --> @dm:implode key_columns ="key" and merge_columns ="ip_address" and dedup_merge_values="yes"
    --> @dm:add-missing-columns columns="unique_id"
    --> @dm:eval-multi-proc created_time="utcnow().isoformat()"
    --> @dm:selectcolumns include="^unique_id$|^ip_address$|^created_time$"
    --> @dm:add-checksum checksum_type="rows-only" and row_checksum_column="unique_id" and key="yes"
    --> @dm:eval splitted_ips = "ip_address.split(',') if ip_address else None"
    --> @dm:save name="temp-ip-list-success"

--> @c:new-block
    --> @dm:recall name="temp-input"
    --> @dm:check-columns must_not_contain="IP" and action="skip-block"
    --> @dm:empty
    --> @dm:addrow name="network_access_verification"  & limit = '0'
    --> #dm:query-persistent-stream
    --> *dm:filter protocol contains "snmp"
    --> *dm:filter auth_state == "Success"
    --> *dm:filter timestamp is after -72h
    --> @dm:dedup columns = "ip_address"
    --> @dm:save name="temp-ips"
    --> @dm:selectcolumns include ="ip_address"
    --> @dm:eval key ="'key'"
    --> @dm:implode key_columns ="key" and merge_columns ="ip_address" and dedup_merge_values="yes"
    --> @dm:add-missing-columns columns="unique_id"
    --> @dm:eval-multi-proc created_time="utcnow().isoformat()"
    --> @dm:selectcolumns include="^unique_id$|^ip_address$|^created_time$"
    --> @dm:add-checksum checksum_type="rows-only" and row_checksum_column="unique_id" and key="yes"
    --> @dm:eval splitted_ips = "ip_address.split(',') if ip_address else None"
    --> @dm:save name="temp-ip-list-success"

--> @c:data-loop columns="ingestion_id" and dataset="temp-input"
    --> @dm:empty
    --> @dm:addrow status = "Successfully collected successful devices list from 'network_access_verification' pstream."
    --> @dm:eval source ="'Logs'"
    --> @dm:eval ingestion_id="'$ingestion_id'"
    --> @dm:eval unique_id = "ingestion_id+'_'+status"
    --> @rn:write-stream name= "discovery_run_details"

--> @c:data-loop columns="ip_address,unique_id" and dataset ="temp-ip-list-success"
    --> @agent:cfx-edgecollector:ec-group-01:createJob jobName = "cisco_ios_$unique_id" & seed_addresses = "$ip_address" & extended_inventory = true & basic_inventory = true & credential_types = "SNMPV1V2"
    --> @agent:cfx-edgecollector:ec-group-01:updateJob jobName = "cisco_ios_$unique_id" & seed_addresses = "$ip_address" & extended_inventory = true & basic_inventory = true  & credential_types = "SNMPV1V2"
    --> @dm:sleep seconds = "10"

--> @c:data-loop columns="ingestion_id" and dataset="temp-input"
    --> @dm:empty
    --> @dm:addrow status = "Successfully created EdgeCollector job."
    --> @dm:addrow status = "Discovering the devices..."
    --> @exec:for-loop
       --> @dm:eval source ="'Logs'"
       --> @dm:eval ingestion_id="'$ingestion_id'"
       --> @dm:eval unique_id = "ingestion_id+'_'+status"
       --> @rn:write-stream name= "discovery_run_details"
    --> @exec:end-loop

## Network Devices Inventory data collection job
--> @c:data-loop columns="ip_address,unique_id" and dataset ="temp-ip-list-success"
    --> @dm:recall name="temp-ip-list-success"
    --> @agent:cfx-edgecollector:ec-group-01:runDiscovery jobName = "cisco_ios_$unique_id" & pstream_name ="network_access_verification" and query ="timestamp is after -72h and ip_address in {{row.splitted_ips}}" and access_verification="False"
    --> @dm:object-to-file input_object_column = "DISCOVERY_ZIP_FILE" & output_column = "DISCOVERY_ZIP_LOCALFILE"
    --> @dm:save name = "discovery_result"
    --> @dm:save name = "temp-discovery-results"

--> @c:data-loop columns="ingestion_id" and dataset="temp-input"
    --> @dm:empty
    --> @dm:addrow status = "Successfully completed the discovery."
    --> @dm:addrow status = "Identifing discovery status for all devices in the zipfile"
    --> @exec:for-loop
       --> @dm:eval source ="'Logs'"
       --> @dm:eval ingestion_id="'$ingestion_id'"
       --> @dm:eval unique_id = "ingestion_id+'_'+status"
       --> @rn:write-stream name= "discovery_run_details"
    --> @exec:end-loop

## create device_ops_view,device_view and poe_summary json files
## create device_ops_view,device_view and poe_summary json files
## create device_ops_view,device_view and poe_summary json files
--> @c:data-loop dataset = "temp-discovery-results" and columns="Minio_location"
    --> @files:ec-entity-analysis input_zipfile_path= "$Minio_location" and output_path = "data/customers/org_id/ingestion/device_data" and device_ops_view = True and device_view = True and poe_summary = True

## ##################################################################
## calculate total number of successful, failed and total devices
## ##########################################################
--> @c:new-block

--> @c:data-loop columns="Minio_location" and dataset="temp-discovery-results"
    --> @dm:empty
    --> @dm:addrow DISCOVERY_ZIP_FILE="$Minio_location"
    --> @files:ec-get-discovery-results minio_file_location ="$Minio_location" & read_failed_devices = "yes" & json_path = "error"
    --> @dm:save name="temp-df" and append= "yes"

--> @c:new-block
    --> @dm:set-tracing-context __block__="parse error"
    --> @dm:recall name="temp-df"
    --> *dm:filter error is not null
    --> @dm:counter
    --> @dm:eval devices_failed = "COUNTER+1"
    --> @dm:eval key = "'key'"
    --> @dm:tail n= 1
    --> @dm:save name = "temp-failed-devices"

--> @c:new-block
    --> @dm:recall name = "temp-df"
    --> @dm:counter
    --> @dm:eval total_devices = "COUNTER+1"
    --> @dm:eval key = "'key'"
    --> @dm:tail n= 1
    --> @dm:save name = "temp-total-devices"

--> @c:new-block

--> @c:data-loop columns="Minio_location" and dataset="temp-discovery-results"
    --> @dm:recall name = "temp-total-devices"
    --> @dm:enrich dict = "temp-failed-devices" and src_key_cols = "key" and dict_key_cols = "key" and enrich_cols = "devices_failed"
    --> @dm:add-missing-columns columns="devices_failed" and value=0
    --> @dm:eval devices_successful = "total_devices- devices_failed"
    --> @dm:selectcolumns include = "total_devices|devices_successful|devices_failed|key"
    --> @dm:eval filename="'$Minio_location'"
    --> @dm:eval filename ="filename.split('/')[-1]"
    --> @dm:enrich dict	 = "temp-input" and src_key_cols	 = "key" and dict_key_cols	="key" and enrich_cols	="ingestion_id"
    --> @dm:save name = "temp-total-discovery-results"

--> @c:new-block

--> @c:data-loop columns="ingestion_id,current_time" and dataset="temp-input"
    --> @dm:recall name = "temp-total-discovery-results"
    --> @dm:eval discovery_time = "'$current_time'"
    --> @dm:eval discovery_status ="'In Progress'"
    --> @dm:eval source  ="'Counts'"
    --> @dm:eval ingestion_id ="'$ingestion_id'"
    --> @dm:eval unique_id = "discovery_time+'_'+ingestion_id+'_'+source"
    --> @dm:to-type columns="discovery_time" and type="int"
    --> @rn:write-stream name = 'discovery_run_details'

## #########################################################3
## ###########################################################################################
## List the all the devices in the zipfile and identify the discovery status for all devices##
## ###########################################################################################
--> @c:new-block

--> @c:data-loop columns="Minio_location" and dataset="temp-discovery-results"
    --> @dm:set-tracing-context __block__="ec-get-discovery-results"
    --> @dm:empty
    --> @dm:addrow DISCOVERY_ZIP_FILE="$Minio_location"
    --> @files:ec-get-discovery-results minio_file_location ="$Minio_location" & read_failed_devices = "yes" & json_path = "error"
    --> @dm:rename-columns reason ="error"
    --> @dm:eval auth_state = "'Success' if not reason else 'Failed'"
    --> @dm:eval filename="'$Minio_location'"
    --> @dm:eval filename ="filename.split('/')[-1]"
    --> @dm:save name="temp-discovery-details"

--> @c:new-block

--> @c:data-loop columns="Minio_location" and dataset="temp-discovery-results"
    --> @dm:set-tracing-context __block__="ec-get-discovery-results"
    --> @dm:empty
    --> @dm:addrow DISCOVERY_ZIP_FILE="$Minio_location"
    --> @files:ec-get-discovery-results minio_file_location = "$Minio_location"   & json_path = "base.credential-id"
    --> @dm:rename-columns cred_used = "base.credential-id"
    --> @dm:save name="temp-credentail-id"

--> @c:new-block

--> @c:data-loop columns="Minio_location" and dataset="temp-discovery-results"
    --> @dm:set-tracing-context __block__="ec-get-discovery-results"
    --> @dm:empty
    --> @dm:addrow DISCOVERY_ZIP_FILE="$Minio_location"
    --> @files:ec-get-discovery-results minio_file_location = "$Minio_location"   & json_path = "base.data"
    --> @dm:rename-columns data = base.data
    --> *dm:filter data is not null
    --> @dm:eval-multi-proc data ="data.replace('[[','[') if str(data).startswith('[[') else data" and _max_procs=4
    --> @dm:eval-multi-proc data ="data.replace(']]',']') if str(data).endswith(']]') else data" and _max_procs=4
    --> @dm:explode-json column='data'
    --> @dm:selectcolumns include="systemVendorName|systemVendorOS|target|filename"
    --> @dm:rename-columns vendor = systemVendorName  and device_fw_typec = systemVendorOS
    --> @dm:save name="temp-base-data"
    --> @dm:enrich dict = "temp-discovery-details" and src_key_cols ="target" and dict_key_cols="target" and enrich_cols ="reason,auth_state,filename" and how_type="outer"
    --> @dm:enrich dict = "temp-credentail-id" and src_key_cols ="target" and dict_key_cols="target" and enrich_cols ="cred_used"
    --> @dm:fixnull columns="reason,cred_used" and apply_for_empty  ="yes" and value="Not Available"
    --> @dm:eval key="'key'"
    --> @dm:enrich dict	 = "temp-input" and src_key_cols	 = "key" and dict_key_cols	="key" and enrich_cols	="ingestion_id"
    --> @dm:save name="temp-discovery-runs-details"

--> @c:data-loop columns="current_time" and dataset="temp-input"
    --> @dm:recall name="temp-discovery-runs-details"
    --> @dm:eval discovery_time = "'$current_time'"
    --> @dm:eval source  ="'Run Details'"
    --> @dm:eval unique_id = "discovery_time+'_'+ingestion_id+'_'+target"
    --> @rn:write-stream name= "discovery_run_details"

--> @c:data-loop columns="ingestion_id" and dataset="temp-input"
    --> @dm:empty
    --> @dm:addrow status = "Successfully identified discovery status for all devices in the zipfile"
    --> @dm:addrow status = "Processing each devices to identify the vendor"
    --> @exec:for-loop
       --> @dm:eval source ="'Logs'"
       --> @dm:eval ingestion_id="'$ingestion_id'"
       --> @dm:eval unique_id = "ingestion_id+'_'+status"
       --> @rn:write-stream name= "discovery_run_details"
    --> @exec:end-loop

## ##########################################################
--> @c:data-loop dataset = "temp-discovery-results" and columns="Minio_location"
    --> @dm:recall name = "temp-discovery-results"
    --> @files:ec-get-discovery-results minio_file_location = "$Minio_location" & json_path = "base.data,system.data,entityPhysical.data,interfaces.data,entAliasMappingTable.data,cdpGlobal.data,ipAddrTable.data,cdpCache.data,cli_show_ether_channel_summary.data,management-target,snmpEngineDetails.data"
    --> @dm:save name="temp-df"

--> @c:simple-loop loop_var="base.data,system.data,entityPhysical.data,interfaces.data,entAliasMappingTable.data,cdpGlobal.data,ipAddrTable.data,cdpCache.data,cli_show_ether_channel_summary.data,management-target,snmpEngineDetails.data"
    --> @dm:set-tracing-context __block__="$loop_var"
    --> @dm:recall name="temp-df"
    --> @dm:selectcolumns include="$loop_var|target"
    --> @dm:rename-columns data="$loop_var"
    --> @dm:add-missing-columns columns="data"
    --> *dm:filter data is not null
    --> @dm:eval-multi-proc data ="data.replace('[[','[') if str(data).startswith('[[') else data" and _max_procs=4
    --> @dm:eval-multi-proc data ="data.replace(']]',']') if str(data).endswith(']]') else data" and _max_procs=4
    --> @dm:explode-json column='data'
    --> @dm:save name="temp-Group-$loop_var"

## temp-ifindex-entPhysicalIndex DATASET: Create 'ifIndex' & 'entPhysicalIndex' mapping columns by reading entAliasMappingTable group
--> @c:new-block
    --> @dm:set-tracing-context __block__="entity-alias-mapping"
    --> @dm:recall name="temp-Group-entAliasMappingTable.data"
    --> @dm:skip-block-if-shape row_count='0'
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:add-missing-columns columns="if_index,entPhysicalIndex,entAliasMappingIdentifier"
    --> @dm:eval-multi-proc if_index=" entAliasMappingIdentifier[entAliasMappingIdentifier.rfind('.') + 1: len(entAliasMappingIdentifier)] if entAliasMappingIdentifier else None" and _max_procs=4
    --> *dm:filter if_index is not None
    --> @dm:selectcolumns include="target|if_index|entPhysicalIndex"
    --> @dm:to-type columns="entPhysicalIndex" and type="int"
    --> @dm:to-type columns="if_index" and type="int"
    --> @dm:save name="temp-ifindex-entPhysicalIndex"

--> @c:new-block
    --> @dm:recall name="temp-Group-entityPhysical.data"
    --> @dm:skip-block-if-shape row_count='0'
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:add-missing-columns columns="entPhysicalClassEnumeratedLabel,entPhysicalIndex"
    --> *dm:filter entPhysicalClassEnumeratedLabel in ["Port","port","PORT"]
    --> @dm:to-type columns="entPhysicalIndex" and type="int"
    --> @dm:eval entPhysicalSerialNum="target+'_sn' if not entPhysicalSerialNum else entPhysicalSerialNum"
    --> @dm:enrich dict="temp-ifindex-entPhysicalIndex" and src_key_cols="target,entPhysicalIndex" and dict_key_cols="target,entPhysicalIndex" and enrich_cols="if_index"
    --> @dm:add-missing-columns columns="if_index"
    --> @dm:to-type columns="if_index" and type="int"
    --> @dm:save name="temp-entityPhysical_logical_data"

## Read interfaces data
--> @c:new-block
    --> @dm:recall name="temp-Group-interfaces.data"
    --> @dm:skip-block-if-shape row_count='0'
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:to-type columns="ifIndex" and type="int"
    --> @dm:enrich dict="temp-entityPhysical_logical_data" and src_key_cols="target,ifIndex" and dict_key_cols="target,if_index" and enrich_cols="entPhysicalDescr,entPhysicalContainedIn,entPhysicalClass,entPhysicalName,entPhysicalSoftwareRev,entPhysicalSerialNum,entPhysicalModelName,entPhysicalVendorName,entPhysicalClassEnumeratedLabel,entPhysicalAlias,entPhysicalIndex"
    --> @dm:add-missing-columns columns="entPhysicalDescr,entPhysicalContainedIn,entPhysicalClass,entPhysicalName,entPhysicalSoftwareRev,entPhysicalSerialNum,entPhysicalModelName,entPhysicalVendorName,entPhysicalClassEnumeratedLabel,entPhysicalAlias,entPhysicalIndex"
    --> @dm:to-type columns="ifIndex" and type="int"
    --> @dm:to-type columns="entPhysicalIndex" and type="int"
    --> @dm:eval type="'PORT_CHANNEL' if ifDescr and ifDescr.startswith('Port-channel') else 'PHYSICAL_PORT' if entPhysicalIndex else 'LOGICAL_PORT'"
    --> @dm:save name="temp-interface"

## Read Port Channel Inventory
## temp-cli_show_ether_channel_summary DATASET: Port Channel Name
--> @c:new-block
    --> @dm:set-tracing-context __block__="port-channel-interfaces"
    --> @dm:recall name="temp-Group-cli_show_ether_channel_summary.data"
    --> @dm:fixcolumns
    --> @dm:save name ="temp-Group-cli_show_ether_channel_summary"
    --> @dm:metadata
    --> *dm:filter column is 'Group'
    --> @dm:skip-block-if-shape row_count='0'
    --> @dm:recall name ="temp-Group-cli_show_ether_channel_summary"
    --> *dm:filter Group is not empty
    --> @dm:selectcolumns exclude = '^data$'
    --> @dm:grok column = 'Port_channel' & pattern = "%{DATA:port_channel_name}\("
    --> @dm:map attr = 'Ports' & func = 'replace' & oldvalue = ' ' & newvalue = ','
    --> @dm:map attr = 'Ports' & func = 'replace' & oldvalue = ',,' & newvalue = ','
    --> @dm:explode column = 'Ports'
    --> @dm:grok column = 'Ports' & pattern = "%{DATA:device_int_shortname}\("
    --> @dm:save name = 'cisco_device_port_channel_dict'

## Read cdp data
--> @c:new-block
    --> @dm:set-tracing-context __block__="parse-cdp-cache"
    --> @dm:recall name="temp-Group-cdpCache.data"
    --> @dm:add-missing-columns columns="data"
    --> *dm:filter data is not "[]"
    --> @dm:skip-block-if-shape row_count='0'
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:to-type columns = 'cdpCacheIfIndex' & type = 'int'
    --> @dm:save name="temp-cdp"

## Enrich interface with cdp data
--> @c:new-block
    --> @dm:recall name="temp-cdp" and return_empty="yes"
    --> *exec:if-shape num_rows > 0
       --> @dm:recall name="temp-interface"
       --> @dm:add-missing-columns columns="target"
       --> @dm:enrich dict="temp-cdp" and dict_key_cols="target,cdpCacheIfIndex" and src_key_cols="target,ifIndex" and enrich_cols="cdpCacheAddress,cdpCacheDevicePort,cdpCacheDeviceId,cdpCachePlatform,cdpCacheCapabilitiesEnumeratedLabel"
       --> @dm:to-type columns="cdpCacheIfIndex" and type="int"
       --> @dm:to-type columns="ifIndex" and type="int"
       --> @dm:save name="temp-interface"
    --> @exec:end-if
    --> *exec:if-shape num_rows = 0
       --> @dm:recall name="temp-interface"
       --> @dm:add-missing-columns columns="target"
       --> @dm:to-type columns="ifIndex" and type="int"
       --> @dm:save name="temp-interface"
    --> @exec:end-if

## Port Chassis SN
--> @c:new-block
    --> @dm:set-tracing-context __block__="get-port-chassis-sr"
    --> @dm:recall name="temp-Group-entityPhysical.data"
    --> @dm:skip-block-if-shape row_count='0'
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:add-missing-columns columns="entPhysicalClassEnumeratedLabel"
    --> *dm:filter entPhysicalClassEnumeratedLabel in ["chassis","Chassis","CHASSIS"]
    --> @dm:rename-columns chassis_phyindex="entPhysicalIndex" & chassis_containedin="entPhysicalContainedIn"
    --> @dm:selectcolumns include="chassis_phyindex|entPhysicalClassEnumeratedLabel|entPhysicalSerialNum|target|entPhysicalName"
    --> @dm:to-type columns="chassis_phyindex" and type="int"
    --> @dm:save name="temp-chassis"
    --> @dm:recall name="temp-Group-entityPhysical.data"
    --> @dm:skip-block-if-shape row_count='0'
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:add-missing-columns columns="entPhysicalIndex,entPhysicalContainedIn,entPhysicalClassEnumeratedLabel"
    --> @dm:build-hierarchy entity_key_column = "entPhysicalIndex" and relation_key_column = "entPhysicalContainedIn" and hierarchy_end_key_column="entPhysicalClassEnumeratedLabel" and hierarchy_end_value="Chassis" and include_column_to_primary_key="target"
    --> @dm:copy-columns from="hierarchy" and to="chassis_phyindex" and func="split" and value="-"
    --> @dm:eval-multi-proc chassis_phyindex="chassis_phyindex[-1] if hierarchy else None" and _max_procs=4
    --> *dm:filter entPhysicalClassEnumeratedLabel in ["Port","PORT","port"]
    --> @dm:rename-columns port_phyindex="entPhysicalIndex"
    --> @dm:to-type columns="chassis_phyindex" and type="int"
    --> @dm:selectcolumns include="port_phyindex|chassis_phyindex|target"
    --> @dm:enrich dict="temp-chassis" and src_key_cols="chassis_phyindex,target" and dict_key_cols="chassis_phyindex,target" and enrich_cols="entPhysicalSerialNum"
    --> @dm:selectcolumns include="port_phyindex|entPhysicalSerialNum|entPhysicalClassEnumeratedLabel|target"
    --> @dm:rename-columns chassis_sn="entPhysicalSerialNum"
    --> @dm:to-type columns="port_phyindex" and type="int"
    --> @dm:gc
    --> @dm:save name="temp-port-chassis-sr"

--> @c:new-block
    --> @dm:empty
    --> @dm:addrow dummy = '10.1.1.1'
    --> @dm:save name ="temp-ifindex-entPhysicalIndex" and append="yes"

--> @c:new-block
    --> @dm:set-tracing-context __block__="merge-port-chassis-sr-to-if"
    --> @dm:recall name="temp-ifindex-entPhysicalIndex"
    --> @dm:skip-block-if-shape row_count='1'
    --> @dm:selectcolumns exclude="dummy"
    --> @dm:recall name="temp-ifindex-entPhysicalIndex"
    --> @dm:skip-block-if-shape row_count='0'
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:recall name="temp-interface"
    --> @dm:enrich dict="temp-port-chassis-sr" and src_key_cols="entPhysicalIndex,target" and dict_key_cols="port_phyindex,target" and enrich_cols="chassis_sn"
    --> @dm:to-type columns="port_phyindex" and type="int"
    --> @dm:to-type columns="entPhysicalIndex" and type="int"
    --> @dm:gc
    --> @dm:save name="temp-interface"

## device_additional_ips: Read 'ipAddrTable' group & create comma separated list of ipAdEntAddr based on target and merge it with temp-df
--> @c:new-block
    --> @dm:set-tracing-context __block__="merge device_additional_ips"
    --> @dm:recall name="temp-Group-ipAddrTable.data"
    --> @dm:add-missing-columns columns="data"
    --> *dm:filter data is not "[]"
    --> @dm:skip-block-if-shape row_count=0
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:fixnull columns="ipAdEntAddr" and value=''
    --> @dm:save name="temp-interface_ip_list_input"
    --> @dm:implode key_columns = "target" and merge_columns="ipAdEntAddr"
    --> @dm:save name="temp-additional-ip"
    --> @dm:recall name="temp-interface_ip_list_input"
    --> @dm:implode key_columns = "target,ipAdEntIfIndex" and merge_columns="ipAdEntAddr" and keep_columns="ipAdEntIfIndex"
    --> @dm:save name="temp-interface-ip-list"
    --> @dm:recall name="temp-interface"
    --> @dm:enrich dict="temp-interface-ip-list" and src_key_cols="ifIndex,target" and dict_key_cols="ipAdEntIfIndex,target" and enrich_cols="ipAdEntAddr" and enrich_cols_as="interface_ip"
    --> @dm:save name="temp-interface"

## mgmt_ip: create mgmt_ip list by reading management-target group & merge with temp-df
## ip_address: Merge temp-df with management-target group & map mgmt ip to ip_address
--> @c:new-block
    --> @dm:set-tracing-context __block__=" map mgmt ip to ip_address"
    --> @dm:recall name="temp-Group-management-target"
    --> @dm:skip-block-if-shape row_count=0
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:sort columns="data,target"
    --> @dm:save name="temp-mgmt"
    --> @dm:implode key_columns="target" and merge_columns="data"
    --> @dm:save name="temp-mgmt-list"
    --> @dm:recall name="temp-interface"
    --> @dm:enrich dict="temp-mgmt-list" and src_key_cols="target" and dict_key_cols="target" and enrich_cols="data" and enrich_cols_as="mgmt_ip"
    --> @dm:enrich dict="temp-mgmt" and src_key_cols="target" and dict_key_cols="target" and enrich_cols="data" and enrich_cols_as="target_ip"
    --> @dm:selectcolumns exclude="^data$"
    --> @dm:save name="temp-interface"

--> @c:data-loop dataset = "temp-discovery-results" and columns="Minio_location"
    --> @dm:recall name = "temp-discovery-results"
    --> @files:ec-get-discovery-results minio_file_location = "$Minio_location" &
            json_path = "system.data"
    --> @dm:rename-columns data="system.data"
    --> *dm:filter data is not null
    --> @dm:explode-json column= "data"
    --> @dm:selectcolumns exclude ='^sysObjectID$|^systemVendorSubID$'
    --> @dm:save name = "temp-system-info"

--> @c:data-loop dataset = "temp-discovery-results" and columns="Minio_location"
    --> @dm:recall name = "temp-discovery-results"
    --> @files:ec-get-discovery-results minio_file_location = "$Minio_location" &
            json_path = "entityPhysical.data"
    --> @dm:rename-columns data="entityPhysical.data"
    --> *dm:filter data is not null
    --> @dm:explode-json column= "data"
    --> @dm:save name="temp-empty-dataset-ent"
    --> @dm:add-missing-columns columns="entPhysicalClassEnumeratedLabel"
    --> *dm:filter entPhysicalClassEnumeratedLabel in [ "Chassis" ]
    --> @dm:save name = "temp-ent-info"

--> @c:data-loop dataset = "temp-discovery-results" and columns="Minio_location"
    --> @dm:recall name = "temp-discovery-results"
    --> @files:ec-get-discovery-results minio_file_location = "$Minio_location" &
            json_path = "base.data"
    --> @dm:rename-columns data="base.data"
    --> *dm:filter data is not null
    --> @dm:explode-json column= "data"
    --> *dm:filter sysDescr contains "Cisco"
    --> @dm:manipulate-string from="sysDescr" and func = "split" and value="Version" and to ="version"
    --> @dm:eval version= "version[1].split(',')[0].split('[')[0].split()[0] if sysDescr else None" and _skip_errors = "yes"
    --> @dm:selectcolumns exclude = "meta_eval_message"
    --> @dm:save name="temp-base"
    --> *dm:filter * get target as 'device_ip',sysDescr as 'device_version_summary',systemManagerIP as 'device_mgmt_ip',systemVendorOS as 'device_fw_type',version as 'device_fw_version'
    --> @dm:save name = 'temp-base-updated-info'

--> @c:new-block
    --> @dm:recall name = 'temp-system-info'
    --> *dm:filter * get sysContact as 'device_contact',sysLocation as 'device_location',sysName as 'device_hostname',target as 'device_ip'
    --> @dm:save name="temp-system-updated-info"

--> @c:new-block
    --> @dm:recall name="temp-empty-dataset-ent" and return_empty ="yes"
    --> @dm:add-missing-columns columns="entPhysicalClassEnumeratedLabel"
    --> *dm:filter entPhysicalClassEnumeratedLabel is null
    --> @dm:eval entPhysicalClassEnumeratedLabel ="'Chassis'"
    --> @dm:save name="temp-empty_entitiphysical-data"

--> @c:new-block
    --> @dm:concat names="temp-ent-info|temp-empty_entitiphysical-data"
    --> @dm:save name="temp-ent-info"

--> @c:new-block
    --> @dm:recall name = 'temp-ent-info'
    --> @dm:save name = 'temp-ent-info'
    --> @dm:add-missing-columns columns="entPhysicalClassEnumeratedLabel,entPhysicalDescr,entPhysicalMfgName,entPhysicalModelName,entPhysicalSerialNum,target"
    --> *dm:filter * get entPhysicalClassEnumeratedLabel as 'device_equip_type',entPhysicalDescr as 'device_eq_description',entPhysicalMfgName as 'device_vendor',entPhysicalModelName as 'device_model',entPhysicalSerialNum as 'device_serial_number',target as 'device_ip'
    --> @dm:enrich dict = 'temp-base-updated-info' & src_key_cols = 'device_ip' & dict_key_cols = 'device_ip' & enrich_cols = 'device_version_summary,device_mgmt_ip,device_fw_type,device_fw_version'
    --> @dm:enrich dict = 'temp-system-updated-info' & src_key_cols = 'device_ip' & dict_key_cols = 'device_ip' & enrich_cols = 'device_contact,device_location,device_hostname'
    --> @dm:eval device_vendor="device_fw_type.split(' ')[0] if not device_vendor else device_vendor "
    --> @dm:map from = 'device_ip' & to = 'unique_id'
    --> @dm:eval device_serial_number="device_ip+'_sn' if not device_serial_number else device_serial_number"
    --> @dm:fixnull-regex columns=".*" and value="Not Available" and apply_for_empty="yes"
    --> @dm:eval device_object = "'Chassis'"
    --> @dm:eval device_vendor="'Cisco Systems' if device_vendor in ['Cisco','Cisco Systems Inc','Cisco Systems','Cisco Systems, Inc.'] else device_vendor"
    --> @dm:eval org_id="'org_id'"
    --> @dm:eval parent_sn="device_serial_number if device_equip_type in ['CHASSIS','Chassis'] else device_serial_number"
    --> @dm:manipulate-string from = "device_hostname" and to = "CLLI_code" and func = "substring" and upper_limit = 8
    --> @dm:eval collection_timestamp = "time_now_as_isoformat()"
    --> @dm:save name = 'temp-ent-info'

## Adding ports counts to chassis
--> @c:new-block
    --> @dm:set-tracing-context __block__="interface parsing"
    --> @dm:recall name="temp-Group-interfaces.data"
    --> @dm:skip-block-if-shape row_count='0'
    --> @dm:skip-block-if-shape column_count=1
    --> @dm:eval ifType="str(int(ifType)).strip() if ifType else ifType"
    --> *dm:filter ifType in ["6","62", "6.0", "62.0"]
    --> @dm:save name="temp-interfaces-ds"
    --> @dm:eval down="'eth_down' if (ifOperStatus==2 and ifAdminStatusEnumeratedLabel=='up') else 'eth_up'"
    --> @dm:eval admin_status = "'admin_down' if (ifAdminStatus==2) else 'admin_up'"
    --> @dm:to-type columns = "ifOperStatus" and type = "int"
    --> @dm:to-type columns="ifType,ifOperStatus,down,admin_status" and type="str"
    --> @dm:implode key_columns="target" and
            merge_columns="ifType,ifOperStatus,down,admin_status,ifName" and dedup_merge_values="no"
    --> @dm:eval total_eth_count="len(ifType.split(','))" &
            up_eth_count="ifOperStatus.split(',').count('1')" &            down_eth_count="total_eth_count-up_eth_count" &            admin_down_count="admin_status.split(',').count('admin_down')"
    --> @dm:selectcolumns include="total_eth_count|up_eth_count|down_eth_count|admin_down_count|target"
    --> @dm:save name="temp-interfaces-counts"
    --> @dm:recall name="temp-ent-info"
    --> @dm:enrich dict="temp-interfaces-counts" and src_key_cols="device_ip" and dict_key_cols="target" and how_type = "outer" and enrich_cols="total_eth_count,up_eth_count,down_eth_count,admin_down_count" and enrich_cols_as="total_eth_ports,up_eth_ports,down_eth_ports,admin_down_eth_ports"
    ## --> @dm:enrich dict="temp-additional-ip" and src_key_cols="target" and dict_key_cols="target" and enrich_cols="ipAdEntAddr" and enrich_cols_as="device_additional_ips"
    --> @dm:save name="temp-ent-info"
    --> @dm:enrich dict = "device_mappings_with_latlongv1" & src_key_cols = "device_ip" & dict_key_cols = "ip_address"  & enrich_cols = "Latitude,Longitude,city,region,zone,network_type,network_code,image" & enrich_cols_as = "latitude,longitude,city,region,zone,network_type,network_code,image"
    --> @dm:selectcolumns exclude = "ip_address"
    --> @dm:eval device = device_hostname
    --> @dm:eval node_label = device_hostname
    --> @dm:eval node_type = device_object
    --> @dm:eval node_id = unique_id
    --> @dm:eval device_status = "'MANAGED'"
    --> @dm:enrich dict = "device_mapping" & src_key_cols="device_ip" & dict_key_cols = "ip_address" & enrich_cols = "zone,network_type,CLLI_code,city,region,network_code,image,device"  & replace_values = "yes" & cache_refresh_seconds = "60"
    --> @dm:save name = 'cisco_device_chassis_dict'
    --> @rn:write-stream name = 'cisco_devices_inventory'

--> @c:new-block
    --> @dm:set-tracing-context __block__=" map source_ip"
    --> @dm:recall name="temp-interface"
    --> @dm:add-missing-columns columns="target_ip,cdpCacheIfIndex,cdpCacheAddress,cdpCacheDevicePort,cdpCachePlatform,cdpCacheDeviceId,cdpGlobalDeviceId,cdpCacheCapabilitiesEnumeratedLabel,"
    --> @cfxaia:conditional-statement condition_column = "target_ip" and return_if = "target_ip" and return_else = "target" and to_column = "ip_address"
    --> @dm:selectcolumns exclude="target-ip|if_index"
    --> @dm:save name="temp-interface"
    --> @dm:add-missing-columns columns="chassis_sn,interface_ip,ifDescr,ifIndex,ifName,ifOperStatusEnumeratedLabel,ifAdminStatusEnumeratedLabel,type,cdpCacheIfIndex,cdpCacheAddress,cdpCacheDevicePort,cdpCacheDeviceId,cdpCachePlatform,cdpCacheCapabilitiesEnumeratedLabel,ifHCInOctets,ifHCOutOctets,ifType,ifLastChange"
    --> *dm:filter * get target as 'device_ip',ifAlias as 'device_int_alias',interface_ip as 'interface_ip',ifDescr as 'device_int_name',ifIndex as 'device_int_index',ifName as 'device_int_shortname',ifOperStatusEnumeratedLabel as 'device_interface_status',ifAdminStatusEnumeratedLabel as 'device_interface_admin_status',type as 'device_interface_type',cdpCacheIfIndex as 'remote_device_int_index',cdpCacheAddress as 'remote_device_ip',cdpCacheDevicePort as 'remote_device_int_name',cdpCacheDeviceId as 'remote_device_id',cdpCachePlatform as 'remote_device_model',cdpCacheCapabilitiesEnumeratedLabel as 'remote_device_capabilities', ifHCInOctets as 'device_int_in_octets' , ifHCOutOctets as 'device_int_out_octets',ifType,ifLastChange as 'if_last_change'
    --> @dm:enrich dict = "temp-Group-snmpEngineDetails.data" and src_key_cols = "device_ip" and dict_key_cols = "target" and enrich_cols = "snmpEngineTime"
    --> @dm:add-missing-columns columns = "snmpEngineTime"
    --> @dm:rename-columns snmp_uptime = "snmpEngineTime"
    ## --> @dm:eval vlan_name="'vlan'+str(vlan_id).strip('.0') if vlan_id is not None and vlan_id!='None' else 'Not Available'"
    --> @dm:to-type columns="snmp_uptime,if_last_change" and type="int"
    --> @dm:manipulate-string from="snmp_uptime" and to="sys_uptime" and func="eval" and value="snmp_uptime*100"
    --> @dm:fixnull columns="sys_uptime" and value=0 and apply_for_empty="yes"
    --> @dm:manipulate-string to="round_up" and func="eval" and value="(sys_uptime - if_last_change)/8640000"
    --> @dm:manipulate-string to="round_up" and func="eval" and value="round_up.round(1)"
    --> @cfxaia:conditional-statement condition_column="sys_uptime" and to_column="flag1" and return_if="yes" and return_else="no" and check_value="yes" and value="0" and operator=">"
    --> @cfxaia:conditional-statement condition_column="if_last_change" and to_column="flag2" and return_if="yes" and return_else="no" and check_value="yes" and value="0" and operator=">"
    --> @cfxaia:conditional-statement condition_column="flag1,flag2" and check_value="yes" and operator="=" and value="yes,yes" and return_if="round_up" and to_column="round_up"
    --> @dm:copy-columns from="round_up" and to="if_last_change"
    --> @dm:eval if_last_change="int(if_last_change) if if_last_change else None"
    --> @dm:selectcolumns exclude="flag|target|round_up"
    --> @dm:to-type columns="if_last_change" and type="int"
    --> @cfxaia:conditional-statement condition_column="if_last_change" and operator=">" and check_value="yes" and value="120" and return_if=">120" and to_column="if_chng_days"
    --> @cfxaia:conditional-statement condition_column="if_last_change" and operator="<" and check_value="yes" and value="60" and return_if="<60" and to_column="if_chng_days" and replace_if_null="true"
    --> @cfxaia:conditional-statement condition_column="if_last_change" and return_if="60-120" and to_column="if_chng_days" and replace_if_null="true"
    --> @dm:eval if_change_since = "int(time_now_as_ms())-if_last_change*24*60*60*1000 if if_last_change is not None else None"
    --> @dm:enrich dict = 'cisco_device_chassis_dict' & src_key_cols = 'device_ip' & dict_key_cols = 'device_ip' & enrich_cols = 'device_eq_description,device_mgmt_ip,device_fw_version,device_fw_type,device_model,device_vendor,device_hostname,device_contact,device_location,device_version_summary,device_serial_number,CLLI_code' and cache="no"
    ## Some times, remote_device_id comes as HOSTNAME(SERIAL_NUMBER)
    --> @dm:map from="remote_device_id" and to="remote_device_name" and func="match" and expr="([^(]+)\(?.*"
    --> @dm:fixnull columns="remote_device_name" and value=""
    ## Following lines check if the remote_device_id is actually a known chassis in cisco_device_chassis_dict.
    ## If it is not, then remove the everything after the .
    ## Because, sometimes, remote_device_id comes as FQDN, but the sysname does not contain the FQDN.
    --> @dm:copy-columns to="old_device_hostname" and from="device_hostname"
    ## --> @dm:enrich dict="cisco_device_chassis_dict" and src_key_cols="remote_device_name" and dict_key_cols="device_hostname" and enrich_cols="device_hostname" and enrich_cols_as="remote_hostname_from_chassis"
    --> @dm:enrich dict="temp-system-info" and src_key_cols="remote_device_name" and dict_key_cols="sysName" and enrich_cols="sysName" and enrich_cols_as="remote_hostname_from_chassis"
    --> @dm:fixnull columns="remote_hostname_from_chassis" and value="NOTFOUND" and apply_for_empty="yes"
    --> @dm:copy-columns to="device_hostname" and from="old_device_hostname"
    --> @dm:eval remote_device_name="remote_device_name.split('.')[0] if remote_hostname_from_chassis == 'NOTFOUND' else remote_device_name"
    ## Setup some dummy hostnames just incase local or remote hostnames are not setup properly.
    --> @dm:eval device_hostname="device_hostname if device_hostname else 'LOCAL_UNKNOWN'"
    --> @dm:eval remote_device_name="remote_device_name if remote_device_name else 'REMOTE_UNKNOWN'"
    ## Create cdp_device_order for enriching the events for correlation purposes
    --> @dm:eval cdp_device_order = "':'.join(sorted([device_hostname, remote_device_name]))"
    --> @dm:selectcolumns exclude="device_version_summary"
    --> @dm:save name = 'cisco_device_interface_data'
    --> @dm:map from = "device_ip,device_int_name" & to = "unique_id" & func = "join" & sep = "_"
    --> @dm:fixnull-regex columns=".*" and value="Not Available" and apply_for_empty="yes"
    --> @dm:eval device_object = "'Interface'"
    --> @dm:eval collection_timestamp = "time_now_as_isoformat()"
    --> @dm:save name = 'cisco_device_interface_data'
    --> @rn:write-stream name = 'cisco_devices_inventory'
    --> @dm:eval link_type="'cdp'"
    --> *dm:filter remote_device_int_name is not empty get device_ip,device_int_name,device_int_shortname,remote_device_ip,remote_device_int_name,remote_device_id,remote_device_capabilities,device_hostname,device_model,device_vendor,device_hostname,device_serial_number,CLLI_code,collection_timestamp
    --> @dm:eval remote_device_capabilities = "'' if remote_device_capabilities == 'Not Available' else remote_device_capabilities"
    --> @dm:manipulate-string from="remote_device_capabilities" and func="join" and value="," and to="remote_device_capabilities"
    --> @dm:eval cdp_device_order = "':'.join(sorted([device_hostname, remote_device_id]))"
    --> @dm:map from = "remote_device_id,remote_device_int_name,device_ip" & to = "unique_id" & func = "join" & sep = "_"
    --> @dm:fixnull columns="remote_device_capabilities" and value="Not Available" and apply_for_empty="yes"
    --> @dm:eval device_object = "'CDP'"
    --> @dm:save name = 'cisco_device_interface_cdp_dict'
    --> @rn:write-stream name = 'cisco_devices_inventory'

--> @c:data-loop columns="ingestion_id,current_time" and dataset="temp-input"
    --> @dm:empty
    --> @dm:addrow name="discovery_run_details"
    --> #dm:query-persistent-stream source = "Counts"
    --> @dm:selectcolumns exclude="timestamp|count_|_RDA_"
    --> *dm:filter discovery_time =="$current_time" and ingestion_id ="$ingestion_id"
    --> @dm:eval discovery_end_time = "int(time_now_as_ms())"
    --> @dm:eval discovery_time = "int(discovery_time)"
    --> @dm:eval discovery_status ="'Completed'"
    --> @dm:to-type columns="discovery_time,discovery_end_time" and type="int"
    --> @dm:selectcolumns include="source|unique_id|ingestion_id|discovery_time|discovery_end_time|discovery_status|devices_failed|devices_successful|total_devices"
    --> @rn:write-stream name= "discovery_run_details"

--> @c:data-loop columns="ingestion_id" and dataset="temp-input"
    --> @dm:empty
    --> @dm:addrow status = "Successfully completed the discovery and processing of the data for all devices."
    --> @dm:eval source ="'Logs'"
    --> @dm:eval ingestion_id ="'$ingestion_id'"
    --> @dm:eval unique_id = "ingestion_id+'_'+status"
    --> @rn:write-stream name= "discovery_run_details"

